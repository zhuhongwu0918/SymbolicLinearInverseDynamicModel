function [N, M, V , C] = RPNA(model, free_base)
%% [N, M, V , C] = RPNA(model, free_base)
% Recursive parameter nullspace algorithm
% The outputs of the algorithm are
% N: cell array for the nullspace descriptors characterizing undetectable
%    inertial transfers across each joint
% M: Basis for minimal paramers (sometimes called representative base
%    parameters) of each link
% V: Attainable velocity span basis for each link
% C: Null(C) gives the unidentifiable parameters of each link
%
% See the accompanying paper for further detail.
%

% compute bases for the the attainable velocity spans Vi, 
% identifiable parameter spans Ki,
% and transfer subspaces Ti.
%速度张量的基，可辨识参数的基，可转移惯量的基
    if nargin == 1
        free_base = 0;
    end

    % Initialize Empty Cell arrays
    EmptyCells = cell(model.NB,1); 
    N   = EmptyCells;   C   = EmptyCells;   O   = EmptyCells;
    M   = EmptyCells;   V   = EmptyCells;   
    V_J = EmptyCells;  
    
    % Main algorithm loop
    for i =1:model.NB%从第1个刚体开始
        [~, Si] = jcalc( model.jtype{i}, 0 );%joint type，关节类型，Rz,Pz
        %返回旋转矩阵和关节自由度向量Si
%         Xj = rotz(q);%绕z轴旋转
%         S = [0;0;1;0;0;0];%关节自由度
%判断各种关节类型，并赋值
        n_i = size(Si, 2);
        %n_i是列数 ，旋转关节是1列
        
        p = model.parent(i);
        %父关节是0
        if p == 0
            % If the base is to be treated as free, set the motion and
            % outer product bases to represent the full space. 
            % Else initialize them from the fixed base.
            if free_base
                Vp = eye(6);
                Cp = eye(10);
            else
                Vp =  get_gravity(model);%构造重力向量
                Cp = zeros(0,10);
            end
        else
            Vp = V{p};%获取父关节的速度，赋值给Vp
            Cp = C{p};
        end
        %速度向外递归
        % Propage the velocity and outer product spans across the link
        V_J{i} = model.Xtree{i} * Vp;%Vp由i转换到J坐标系
       
        % Compute the collection of rate matricies for multi-DoF joints
        %计算多自由度关节的速率矩阵集合
        crmSet = cell( n_i, 1);%n_i是列数 ，旋转关节是1列
        paramRateSet     = cell( n_i, 1);
        %初始化空的元胞数组
        
        for k= 1:size(Si,2)
            % Velocity rates of change with joint angle
            crmSet{k} = crm(Si(:,k));%crmSet就是Phi×，crm叉乘操作，6*6
            
            % 惯性参数变化率Inertail parameters rates of change
            %计算多自由度关节的速率矩阵集合
            paramRateSet{k} = Rate_Parameters( Si(:,k) );
            %将自由度向量进行转换Rate_Parameters？？？原文中有描述
%             paramRateSet{k}是A(Phi_i)，对应公式（34），Rate有求导的含义
%             还没看明白是怎么操作的
%             源代码在AutoGenerated文件夹CreateAutoGeneratedFunctions.m文件中
%             把 Si(:,k)当做v1带入到函数里，最终得到A_phi
        end
        
        % Propagate the velocity across a joint  与算法中第4行对应,公式31
        V{i} = RangeBasis([ SwitchedControllabilityMatrix( crmSet , V_J{i} ), Si]); 
        %velocity spans的基，Bases Vi for the velocity spans
        %RangeBasis给出一个与输入列跨度相同的满秩矩阵
        %对应算法第4行
        O{i} = SwitchedObservabilityMatrix(Cp*Transform_Parameters( model.Xtree{i} ), paramRateSet );
%         Cp*Transform_Parameters( model.Xtree{i} )对应于Ki-
%         Ki- = Cp*Transform_Parameters( model.Xtree{i} ),对应于算法第5行
        %O{i}与算法第6行对应，与公式36上面一个公式对应
%         model.Xtree{i}坐标变换矩阵
        N{i} = OutputMatrix(V{i},Si);
        %对应公式第7行的第一项，M(Vi,Phii)
        for k = 1:n_i
            N{i} = [N{i} ; O{i} * paramRateSet{k}];%paramRateSet{k}是A(Phi_i)
            %与公式第8行对应
        end
        N{i} = RangeBasis(N{i}')';
        C{i} = RangeBasis( [ Cp*Transform_Parameters( model.Xtree{i} ) ; N{i} ]')'; 
        M{i} = UnitVectorComplementarySubspace( null(N{i}) );
        %M provides a matrix whose columns span a complmementary
        %subspace，来自于对角eye矩阵
    end
end